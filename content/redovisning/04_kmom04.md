---
---
Redovisning kmom04
=========================

Vet inte riktigt om allt landat gällande Triat och Interface ännu. Men spontant så tycker jag att det verkar som vettiga konstruktioner. Att ha möjligheten till multipla arv i form av Traits känns ju väldigt relevant när man jobbar med objektorienterad programmering. Att även kunna definiera vissa krav på en klass i form av ett Interface tänker jag att det kan underlätta för andra som utvecklar mot ens klasser för att både vara tydlig vad som krävs men också vad som kan erbjudas för funktionalitet av en klass.

Kan inte påstå att jag är bekant med begreppet kontroller sedan tidigare. Spontant så känns det efter detta kursmoment som att det hade varit enklare att skriva andra egna klasser som hanterade mycket av logiken istället för att använda just en kontroller. Dock kan jag se fördelar med det om man behöver arbeta mot en databas och behöver initiera kopplingar mot databasen på ett enklare sätt via ramverkets inbyggda funktionalitet, en annan fördel är nog möjligheten att i kontroller klassen arbeta på ett sätt där man inte jobbar direkt mot de globala variablerna som t.ex. sessionen.

Spelet denna gång kallar jag Dice 2 i menyn. Det var klurigt att först bestämma vilken typ av intelligens jag skulle implementera i spelet och sedan faktiskt få till den. Jag bestämde mig för att datorn skulle vara försiktig och ha koll på utkomsten av tidigare tärningsslag och hur många slag datorn lyckades göra. Datorn börjar med att göra en serie på ett tärningsslag, varje gång datorn lyckas slå en serie utan en 1a så ökar datorn på antalet slag den gör. Varje gång datorn däremot slår en 1a inom sin serie så minskar datorn sin slagserie med 1.

Med andra ord så börjar datorn med ett slag, misslyckas det så fortsätter datorn med ett slag tills datorn lyckas slå ett kast utan en 1a. När datorn lyckas med en serie på ett slag så sparar datorn poängen och turen går vidare till spelare. Nästa runda så testar datorn att slå två slag istället. Lyckas datorn då slå två slag utan en 1a så sparar datorn sin poäng och turen går till spelaren. Detta fortsätter tills datorn slår en 1a inom sin serie och då testar datorn att kasta tärningarna en gång mindre. Dvs misslyckas datorn med att kasta tärningarna tre gånger så kommer datorn nästa runda testa att kasta tärningarna två gånger och se ifall det lyckas utan att få en 1a.

Personligen blir jag väldigt frustrerad när jag jobbar med Anax ramverket. Om jag jämför med t.ex. Mithril som vi arbetar med i webbapp kursen så upplever jag att jag fastnar mycket oftare och mycket längre tid på ramverksspecifika problem i Anax. Ju mer jag jobbar med ramverket desto enklare blir det ju dock. Men det känns som jag spenderade största delen av min tid i kursmomentet med att lära mig Anax specifika saker snarare än att jag lär mig om oophp och ramverk ur ett generellt perspektiv. Det skulle ju kännas ok om jag trodde att jag skulle arbeta med Anax i framtiden, och det kanske blir så men just nu skulle jag inte personligen välja det p.g.a. av alla problem jag upplever att jag konstant stöter på.

Make test fungerade dock bra. När jag väl fått Xdebug på plats från förra veckans hårutslitande eskapader så rullade det på bra denna gång. Jag lyckades testa alla mina klasser inklusive kontrollerklassen. Utan Mikaels videos hade jag nog dock inte lyckats testa kontrollerklassen. Jag uppnådde 100% på alla mina egna klasser förutom mitt HistogramTrait, men om jag förstod det hela rätt så var den metod jag inte lyckades testa överlagrad inom Dice klassen så den metoden var ju lite extra svår att testa. Sedan kan man ju fundera på ifall mina tester bara fick hög kodtäckning eller verkligen gjorde vettiga assertions. I mina egna klasser kände jag att jag lyckades få till vettiga assertions men kontrollerklassen blev mest fokus på kodtäckning snarare än att säkerställa att allt fungerade som jag ville med hjälp av många olika assertions, så där finns förbättringspotential.

TIL som jag tar med mig denna gång var nog primärt PHP Traits och Interface funktionerna för att kunna använda dem framöver. I kodtestning blev det tydligare att det är skillnad på kodtäckning och bra kodtäckning.
